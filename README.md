# goit-algo-HW-10
Завдання 1:

✅ Приклади результатів

Для суми 113:

Жадібний алгоритм: {50: 2, 10: 1, 2: 1, 1: 1} → 5 монет

Динамічне програмування: {50: 2, 10: 1, 2: 1, 1: 1} → 5 монет

Для цього набору монет жадібний алгоритм дає оптимальне рішення. Але для інших наборів монет, де співвідношення не дозволяє жадібно знайти мінімум, динамічне програмування завжди знайде мінімальну кількість монет.

⏱ Аналіз ефективності
Алгоритм	Часова складність	Примітка
Жадібний	O(n) для n номіналів	Дуже швидкий, але не завжди оптимальний
Динамічне програмування	O(amount * n)	Гарантовано мінімальна кількість монет, працює для будь-якого набору монет

Для малих сум та класичних наборів монет жадібний алгоритм достатньо ефективний.

Для великих сум або нетипових наборів монет динамічне програмування є надійнішим, оскільки завжди знаходить оптимальний розв’язок.

Завдання 2:

✅ Пояснення коду

Функція f(x): визначає інтегрувану функцію (x^2 у прикладі).

Метод Монте-Карло: генерує випадкові точки в інтервалі [a, b] і усереднює значення функції, множачи на ширину інтервалу (b - a).

Функція quad: обчислює інтеграл аналітично з оцінкою похибки.

Побудова графіка: відображає функцію та область інтегрування для наочності.

Висновки: порівнюється точність результату Монте-Карло з аналітичним розв’язком.

⏱ Рекомендації щодо точності

Чим більша кількість випадкових точок (num_samples), тим точніший результат.

Метод Монте-Карло добре підходить для високовимірних інтегралів, де аналітичне інтегрування складне або неможливе.

Для одновимірних інтегралів quad зазвичай точніший і швидший.